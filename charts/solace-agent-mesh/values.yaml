# Sam configuration
sam:
  enterprise: true
  # Authentication and authorization configuration
  # When enabled, SAM will enforce RBAC authorization
  # When disabled (for dev/quickstart), all users have admin access
  authentication:
    enabled: true
  # DNS name configured in Agent Mesh (SAM) for accessing the web UI and API
  # This should be a DNS-resolvable name pointing to the LoadBalancer IP
  # assigned to the service by your cloud provider
  dnsName: "dns-hostname-here" # e.g., sam.example.com
  sessionSecretKey: "my-secret-key"
  # The oidc configuration is required for enterprise mode with authentication
  # If not using OIDC, set the oidc section to null or remove it
  # and the authentication will be disabled
  oauthProvider:
    oidc:
      issuer: "" # e.g., https://accounts.google.com, leave empty to turn off oidc.
      clientId: "oidc-client-id-here" # e.g., your-client-id
      clientSecret: "oidc-client-secret-here" # e.g., your-client-secret

  # User to role assignments for RBAC
  authenticationRbac:
    users:
      - identity: "admin@example.com" # can be email, username, name, etc.
        roles: ["sam_admin"]
        description: "SAM Administrator Account"
      - identity: "user1@example.com"
        roles: ["sam_user"]
        description: "Standard SAM User"

# Solace Broker configuration
# This is required to connect to provide connectivity to SAM components
broker:
  url: "wss://broker-url:port" # e.g., wss://mr2zq0g0f1.messaging.solace.cloud:443
  clientUsername: "broker-username"
  password: "broker-password"
  vpn: "broker-vpn-name"

# LLM Service configuration
# This is required to connect to your LLM service (e.g., OpenAI)
llmService:
  planningModel: "planningModel" # e.g., "gpt-4o"
  generalModel: "generalModel" # e.g., "gpt-4o"
  reportModel: "reportModel" # e.g., "gpt-4o"
  imageModel: "imageModel" # e.g., "dall-e-3"
  transcriptionModel: "transcriptionModel" # e.g., "whisper-1"
  llmServiceEndpoint: "https://api.openai.com/v1"
  llmServiceApiKey: "your-llm-service-api-key"

# Kubernetes Service configuration
# This defines how the SAM service is exposed within the cluster
service:
  # Service type: ClusterIP (default), NodePort, or LoadBalancer
  # ClusterIP: Internal cluster access only (use with port-forward or Ingress)
  # NodePort: Exposes service on each node's IP at a static port
  # LoadBalancer: Provisions a cloud load balancer (requires cloud provider or MetalLB)
  type: ClusterIP

  # Annotations for the service (e.g., cloud-specific load balancer configurations)
  annotations: {}
    # Example for AWS:
    # service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
    # Example for GCP:
    # cloud.google.com/load-balancer-type: "Internal"

  # NodePort configuration (only used when type: NodePort)
  # Leave empty for automatic port assignment
  nodePorts:
    http: ""      # 30000-32767
    https: ""     # 30000-32767
    auth: ""      # 30000-32767

  # TLS/SSL configuration
  # If enabled, TLS cert and key must be provided via --set-file during helm install
  # to mount them as Kubernetes secrets
  # The certificate must be a publicly trusted cert or a cert signed by a trusted CA
  # Self-signed certs are not supported
  tls:
    enabled: true
    cert: ""
    key: ""
    passphrase: ""

# Kubernetes Ingress configuration
# Ingress provides HTTP/HTTPS routing to the SAM service
# This is the recommended approach for production environments
# NOTE: When using Ingress, TLS termination typically happens at the Ingress/ALB level
# using certificates managed by cert-manager or AWS ACM. You can disable service.tls
# and use HTTP backends (port 80) for better performance.
ingress:
  enabled: false

  # Ingress class name (e.g., nginx, traefik, gce, alb)
  # Leave empty to use the cluster's default ingress class
  className: ""

  # Annotations for the ingress resource
  # These vary by ingress controller
  annotations: {}
    # Example for NGINX Ingress Controller:
    # nginx.ingress.kubernetes.io/ssl-redirect: "true"
    # nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
    # Example for cert-manager (automatic TLS):
    # cert-manager.io/cluster-issuer: "letsencrypt-prod"
    # Example for AWS ALB Ingress Controller:
    # alb.ingress.kubernetes.io/scheme: internet-facing
    # alb.ingress.kubernetes.io/target-type: ip
    # alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:region:account:certificate/id
    # alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}, {"HTTPS":443}]'
    # external-dns.alpha.kubernetes.io/hostname: sam.example.com

  # Ingress hosts configuration
  # Leave host empty for ALB/ELB ingress controllers (accepts all hostnames)
  # Set host for name-based virtual hosting
  hosts:
    - host: ""  # Optional: set to sam.example.com for host-based routing
      paths:
        - path: /
          pathType: Prefix
          # Port name: webui, webui-tls, or auth
          portName: webui-tls

  # TLS configuration for ingress
  tls: []
    # - secretName: sam-tls
    #   hosts:
    #     - sam.example.com


# Additional environment variables for SAM configuration
# These are injected into the containers and used for runtime configuration
# Note: Variables already configured through dedicated values.yaml sections
# (solaceBroker, llm, sam, tls, global.persistence) should not be duplicated here
environmentVariables: {}
  # Example custom variables:
  # CUSTOM_VAR: "value"
# ANOTHER_VAR: "another-value"

# Persistence configuration (for PostgreSQL and SeaweedFS)
# This is required for enterprise mode to store data persistently
# and survive pod restarts or rescheduling
# Do not use this for production environment, bring you own sql and
global:
  persistence: #Check with SAM for a better name. Maybe default_persistence to say that we enable postgres and seaweedfs
    namespaceId: "solace-agent-mesh"
    enabled: false

# SAM Deployment configuration
samDeployment:
  # Kubernetes Service Account configuration
  # The service account must have permissions to create and manage resources
  # such as Deployments, Services, ConfigMaps, and Secrets
  serviceAccount:
    name: solace-agent-mesh-sa

  # imagePullSecret: ""

  # Main SAM application container image
  image:
    repository: gcr.io/gcp-maas-prod/solace-agent-mesh-enterprise
    tag: 1.6.3
    pullPolicy: Always


  # Agent Deployer image (required for enterprise mode)
  # This container is responsible for deploying and managing agents
  agentDeployer:
    image:
      repository: gcr.io/gcp-maas-prod/sam-agent-deployer
      tag: 1.1.2
      pullPolicy: Always
    chartUrl: "https://solaceproducts.github.io/solace-agent-mesh-helm-quickstart/sam-agent-1.0.0.tgz"

  # Deployment strategy and update configuration
  # use Recreate as SAM does not support multiple replicas
  # at this time
  rollout:
    rollingUpdate: {}
    strategy: RollingUpdate

  # Pod security context and container security context
  podSecurityContext:
    runAsUser: 10001
    fsGroup: 10002
  securityContext:
    allowPrivilegeEscalation: false

  # Scheduling and labeling configuration
  nodeSelector: {}
  tolerations: []
  annotations: {}
  podAnnotations: {}
  podLabels: {}

  # Resource requests and limits for the SAM and Agent Deployer containers
  # Adjust these values based on your workload and cluster capacity
  resources:
    sam:
      requests:
        cpu: 1000m
        memory: 1024Mi
      limits:
        cpu: 2000m
        memory: 2048Mi
    agentDeployer:
      requests:
        cpu: 100m
        memory: 256Mi
      limits:
        cpu: 200m
        memory: 512Mi

dataStores:
  database:
    protocol: "postgresql+psycopg2"
    host: ""
    port: "5432"
    adminUsername: ""
    adminPassword: ""
    supabaseTenantId: ""  # Supabase project ID (qualifies usernames as username.projectid when using Supabase's connection pooler on an IPv4 network)
  s3:
    endpointUrl: ""
    bucketName: ""
    accessKey: ""
    secretKey: ""

persistence-layer:
  postgresql:
    commonLabels:
      app.kubernetes.io/service: "database"
  seaweedfs:
    commonLabels:
      app.kubernetes.io/service: "s3"